\documentclass{article}
\usepackage{arxiv}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}    
\usepackage{hyperref}      
\usepackage{url}            
\usepackage{booktabs}       
\usepackage{amsfonts}       
\usepackage{nicefrac}       
\usepackage{microtype}      
\usepackage{cleveref}       
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{doi}
\usepackage{caption}
\usepackage{braket}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{titlesec}
\usepackage[rightcaption]{sidecap}

\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\makeatletter
\renewcommand\subsubsubsection{\@startsection{paragraph}{4}{\z@}{-2.5ex\@plus -1ex \@minus -.25ex}{1.25ex \@plus .25ex}{\normalfont\normalsize\bfseries}}
\newcommand\subsubsubsubsection{\@startsection{subparagraph}{5}{\z@}{-2.5ex\@plus -1ex \@minus -.25ex}{1.25ex \@plus .25ex}{\normalfont\normalsize\bfseries}}
\makeatother



\title{Quantum Oracles - How to Transform Classical Problems into Quantum ones}

\date{\today}



\author{ 
	\href{https://orcid.org/0009-0008-9134-5974}{\includegraphics[scale=0.06]{orcid.pdf}\hspace{1mm}Alexandre Silva}\\
	Computer Science\\
	UNIVEM - Centro Universitário Eurípides de Marília\\
	\And
	\href{http://lattes.cnpq.br/5170103189904688}{\hspace{1mm}Luis Hilário Tobler Garcia} \\
	Computer Science\\
	UNIVEM - Centro Universitário Eurípides de Marília\\
	\And
	\href{http://lattes.cnpq.br/7265559606596355}{\hspace{1mm}Maúricio Duarte} \\
	Information Technology \\
	Fatec Garça – Deputado Julio Julinho Marcondes de Moura\\
}

\graphicspath{ {../images/} }

\renewcommand{\headeright}{}
\renewcommand{\undertitle}{}
\renewcommand{\shorttitle}{}


\hypersetup{
	pdftitle={Quantum Oracles - Como transformar problemas classicos em quanticos},
	pdfsubject={quantum computing, computer science, ciências da computação, computação quântica, algoritmos, algorithms, problem solving, problems, solução de problemas, problemas},
	pdfauthor={Alexandre Silva},
	pdfkeywords={quantum oracles, quantum, quantum computing, algoritmos, algorithms, problems, problemas},
}

\begin{document}
\maketitle
\begin{abstract}
	Using quantum oracles and other effects, like superposition, \emph{5 mini-projects} were done. The main goal of these projects was to answer if it's possible to bring some problems to the quantum realm and if such translation worth it. After finishing the tests, it was possible to see that, some of the implementations show descent results. However, classical computing is still a fundamental part of quantum algorithms.
\end{abstract}


\section{Introduction}
Now days, isn't difficult to hear someone talking about quantum computers, and how these machines will change the world. Nonetheless, the major fraction of these comments come from extrapolations and science fiction present in popular movies and series around the world. In this paper, I'm going to show that quantum computing it's not a magical trick to solve everything, but a tool for solving a distinct group of problems.\\
To do that, \emph{5 mini-projects} were implemented using \href{https://www.ibm.com/quantum/qiskit}{qiskit}, an open source framework from \href{https://www.ibm.com/}{IBM}, exploiting quantum effects and using classical/quantum algorithms to reach the expected outcomes. After that, the results will be here compared with their classical counterparts.
Such mini-projects are the following: Quantum File explorer\ref{file-explorer}, miles to kilometers conversion\ref{conversion}, Hanoi towers\ref{hanoi}, Buckshot Roulette \ref{buckshot} and QRAM \ref{qram}. All these implementations can be found at \href{https://github.com/Dpbm/scientific-initiation-1-quantum-oracles}{my GitHub repository}.

\section{Oracles}
Based on the idea of \emph{Oracle Turing Machines} \cite{SOARE2009368}\cite{amreen_oracle}\cite{kalyanasyndaram_2021_mod04lec23}\cite{e21080800}, the Oracles are mathematical modeling tools, used to abstract outlying parts of an algorithms into a black-box, making the algorithm analysis much easier. These machines could also be seen as a function, getting an input $x$ e returning $f(x)$ with time-complexity $O(1)$. Because of these unreachable characteristics for real life, this model can't be implemented, being used only for formal description of decision problems.\\
However, in quantum computing, it's possible to implement something similar to that, taking advantage of your inner structure and quantum effects to gain a \emph{Speed-up} relative to its classical counterparts, such Speed-up can be seen, for example, in the Deutsch–Jozsa algorithm \cite{Fan_2007}. Furthermore, the Quantum Oracles have a fundamental role determining the circuit complexity. Some approaches for that are: \emph{depth}, calculating the longest path in the circuit that some information must pass through and \emph{gate counting}, summing up how many gates were applied in the final circuit. Nevertheless, these approaches are very dependent of the \emph{QPU} topology, differing from each \emph{backend} used during the \emph{transpilation} process. To solve this problem, a well-known technique is to pack some parts of the circuit into Oracles, and then describing the complexity based on how many times they are called, it's also known as \emph{query complexity} \cite{odonnell_2015_lecture} \cite{e21080800}.

\subsection{Types of Oracles}
Using the base description of Quantum Oracles, we can classify them based on their structures and how the data is processed.

\subsubsection{Phase Oracle}
The Phase Oracle, is the most well-known format. Some Algorithms, like Deutsch–Jozsa, Grover, Simon and Bernstein–Vazirani, use it to take advantage over Classical approaches.

\subsubsubsection{Default Behavior}
As its main characteristic, the Phase Oracle adds a global phase to the circuit, using quantum effects like \emph{Phase Kickback} (basically the phase pass all the way through CNOT's target and is applied in the control Qubit), to change values in superposition.

\begin{center}
	\includegraphics[scale=0.3]{phase_oracle_1.png}
	\captionof{figure}{Phase Oracle using Phase-Kickback Example}
	\label{fig:phase-oracle-1}
\end{center}

In the Figure \ref{fig:phase-oracle-1}, a $\pi$ phase was added in the auxiliary Qubit ($q3$), taking advantage of the phase $\ket{-}$, which will be the responsible to modify the values in the unitary matrix. In this setup, the $CNOT$ gates act slightly different from its default behavior, this way, the gate invert the value of the target Qubit and, due the $\pi$ phase, it also acts like a $Z$ gate applied in the control Qubit. So, after applying $CNOT\ket{-}\ket{+}$ (little-endian), the state becomes ${\frac{1}{\sqrt{2}}}{(\ket{0}\ket{-} - \ket{1}\ket{-})}$, and after removing the superposition, the final state is: ${\frac{1}{\sqrt{2}}}{(\ket{+}\ket{1} - \ket{-}\ket{1})}$. This way, the control Qubit is changed due the \emph{Phase Kickback} and its state is flipped from $\ket{0}$ to $\ket{1}$. Taking this effect as and advantage, we can use it to encode some binary values inside these oracles and use them to do some calculations.

\subsubsubsection{Minimal Oracle Version}

Furthermore, There's another layout possible for implementing a Phase Oracle. Once this one only applies a phase in some bit-strings, the auxiliary Qubit can be removed, and the phase can be provided by $CZ$ gates (or any other gate which can apply a phase for certain bit-strings). Doing that, it's possible to create a phase oracle keep its unitary and reversible nature, in the format of a minimal Oracle.

\begin{center}
	\includegraphics[scale=0.3]{phase_oracle_2.png}
	\captionof{figure}{Phase Oracle - Minimal Oracle Layout Example}
	\label{fig:phase-oracle-2}
\end{center}

In the example above \ref{fig:phase-oracle-2}, a $MCP$ gate was applied adding a $\pi$ phase and another two $X$ gates were used to invert the Qubits we want to have the value $0$ as a trigger for the $MCP$ phase application. Following the little-endian format the final encoded bit-string is: $011_{2}$ or $3_{10}$.

\begin{center}
	\includegraphics[scale=0.5]{phase_oracle_unitary.png}
	\captionof{figure}{Figure \ref{fig:phase-oracle-2} Resulting Unitary Matrix}
	\label{fig:phase-oracle-unitary}
\end{center}

Looking at its unitary matrix, it's possible to see the $8\times8$ identity matrix with a $-1$ in the column relative to the value $011_{2}$.


\subsubsection{Boolean Oracle}
The Boolean Oracle has a similar structure with the Phase Oracle. However, this time a phase isn't applied, acting this way a regular boolean function, mapping inputs to outputs.

\begin{center}
	\includegraphics[scale=0.3]{balanced-oracle.png}
	\captionof{figure}{Boolean Oracle Example}
	\label{fig:boolean-oracle}
\end{center}

The example in the Figure \ref{fig:boolean-oracle}, is a well-known balanced Oracle for the Deutsch-Jozsa's algorithm. Nevertheless, to implement it, the Oracle must be transformed into a Phase Oracle.

\subsubsection{Minimal Oracle}
As previously mentioned, the Minimal Oracle is a function which its essence is unitary and reversible, so no additional Qubits are required. Therefore, this format can be either Boolean or Phase Oracle, depending on its implementation.

\begin{center}
	\includegraphics[scale=0.3]{minimal-oracle.png}
	\captionof{figure}{Boolean Minimal Oracle example}
	\label{fig:minimal-oracle}
\end{center}

In the previous example \ref{fig:minimal-oracle}, two $SWAP$ gates were used to invert the order of the Qubits values. Like this, the final matrix keeps unitary and reversible.

\subsubsection{QFT(Quantum Fourier Transform)}
The QFT is, in a nutshell, a quantum algorithm based on the Discrete Fourier Transform, used for quantum states period finding, projecting values from the computational basis onto the $X$ basis (also know as Fourier basis).

Even though it's an algorithm by itself, its application is done in the format of Oracles in quantum circuits.

\begin{center}
	\includegraphics[scale=0.3]{QFT_1.png}
	\captionof{figure}{QFT Oracle example}
	\label{fig:QFT}
\end{center}

\begin{center}
	\includegraphics[scale=0.3]{QFT_1_bloch.png}
	\captionof{figure}{Values Mapped onto Fourier basis example (quantum state $\ket{000}$)}
	\label{fig:QFT-bloch}
\end{center}


\subsubsection{Other kinds of Oracles}
In addition to the oracles mentioned above, it's possible come across with different mentions of Oracles, like the Simons's, Deutsch-Jozsa's, etc. However, these are just implementations of models already shown in this paper. Also, the most relevant for the following projects are the Phase and Boolean ones, due that, there's no use to keep discussing about many others sub-categories of Oracles here.
\newpage

\section{Development}


\subsection{File Explorer} \label{file-explorer}
Imagine a quantum computer, but instead of one of those we already have in real life, imagine a different kind, very similar to those we have at home, with a quantum operational system, quantum files, etc. This imaginary version could be thought as a hybrid computer as well, taking advantage of both quantum and classical capabilities. Using this idea, the first project implements a file explorer for this ideal system.

\subsubsection{Algorithms Used}

\subsubsubsection{Grover}
The Standard algorithm for search problems is the Grover's algorithm. This one, realizes searches on unsorted "databases" (bit-string in this case) with $O(\sqrt{2^n})$, being $n$ the number of Qubits. Its tenets are based on amplitude amplification, using a Phase Oracle to mark some bit-strings and then using a Diffuser to amplify the probability to find these values after measuring it.



\begin{center}
	\includegraphics[scale=0.25]{Grover.png}
	\captionof{figure}{Example Grover's algorithm with $3$ Qubits}
	\label{fig:grover-default-circuit}
\end{center}

For building the circuit, is needed a joint of $Oracle + Diffuser$ applied $k$ time, which $k \approx { {\pi \over {4 \sqrt{a\over{2^n}}}} - {1\over2}  }$, being $a$ the number of values marked by the Oracle. Once we want to find just a single file, the use of this relation is not required, being need to apply the algorithm once to find the bit-string.

Even this being the best option for bit-string finding, in this project different rotations were tested trying to find a better superposition which increases the chances to find the value we want.

%FIX THIS IMAGE%
\begin{SCfigure}[0.45][h]
	\caption{Comparing the Standard Grover's algorithm with the version modifying the rotation angles $[0, 2\pi]$ for each 4 bits bit-string}
	\includegraphics[scale=0.45]{improvement-grover-algorithm-4bits-0-to-2pi.png}
	\label{fig:best-angle-grover}
\end{SCfigure}

\newpage

Ao utilizar as rotações específicas para cada bit-string, é possível conseguir melhores resultados ao medir os valores na saída, se sobressaindo em relação a rotação padrão.

\begin{center}
	\includegraphics[scale=0.4]{new-grover-test-different-bit-strings-with-optimal-angles.png}
	\captionof{figure}{Teste utilizando os melhores ângulos de cada bit-string em bit-strings diferentes}
	\label{fig:best-angles-diff-bit-strings-grover}
\end{center}

No entanto, ao utilizar esses valores com outras bit-strings, os resultados não conseguem alcançar tal limiar, além modificar as outras probabilidades de forma irregular. Sendo assim, a rotação convencional é a melhor na maioria das vezes.\\
Além disso, para bit-strings de dois bits, utilizar a superposição dada por $H$ se mostra a melhor alternativa.

\begin{center}
	\includegraphics[scale=0.5]{classical_grover_for_1_bit_strings_l2_outcomes.png}
	\captionof{figure}{Resultado Grover padrão encodado uma bit-string de 2 bits}
	\label{fig:l2-grover-classical-outcomes}
\end{center}

\begin{center}
	\includegraphics[scale=0.5]{new_grover_for_1_bit_strings_l2_outcomes.png}
	\captionof{figure}{Resultado Grover modificado encodado uma bit-string de 2 bits}
	\label{fig:l2-grover-new-outcomes}
\end{center}

Com isso, para ter o melhor dos dois mundos, foi usado uma versão híbrida do algoritmo. Assim, para criar o circuito, é passado o valor a ser encodado por uma Hash-Table com os ângulos otimizados. Dessa forma, é possível maximizar as probabilidades de encontrar, nesse caso, o arquivo que está sendo procurado.

\subsubsubsection{Diferença de conjuntos}
Sobrepondo dois Phase Oracles distintos, com ranges de valores diferentes, é realizada a operação de diferença entre conjuntos \cite{sanchezrivero2023initial}.

\begin{center}
	\includegraphics[scale=0.3]{less_than.png}
	\captionof{figure}{Exemplo - diferença de conjuntos}
	\label{fig:less-than-circuit}
\end{center}

Nesse exemplo \ref{fig:less-than-circuit} foi encodado no primeiro Oracle o set $\{000, 001, 010, 0110\}$ e no segundo $\{000, 001, 010, 011, 100, 101\}$.

\begin{center}
	\includegraphics[scale=0.5]{less_than_unitary.png}
	\captionof{figure}{Resultado da diferença de conjuntos}
	\label{fig:less-than-circuit-unitary}
\end{center}

Ao sobrepô-los \ref{fig:less-than-circuit-unitary}, apenas os valores $\{100, 101\}$ permaneceram com a fase, representando então a sobreposição delas.


\subsubsection{Solução}

Para a solução do problema, foi criado uma hash function $C: v \to c$, da qual $v$ é o path de um arquivo e $c$ sua bit-string respectiva. Com essa função em mãos, podemos utilizar o conjunto dos valores retornados e encodá-los em um Phase Oracle, criando então uma Look-Up-Table para os arquivos existentes na máquina (agindo como a memória).\\
Além disso, é necessário utilizar um segundo Oracle para a pesquisa, encodando todos os valores existentes, menos os que foram requisitados. Assim, ao realizar a diferença entre conjuntos, apenas os valores procurados se manterão marcados.

\begin{center}
	\includegraphics[scale=0.4]{sets-difference-look-up-table-oracle.png}
	\captionof{figure}{Diferença de conjuntos com as Look-Up-Tables}
	\label{fig:luts}
\end{center}


Por fim, é usado o aprimoramento dos ângulos para conseguir melhores probabilidades.

\begin{center}
	\includegraphics[scale=0.4]{improved_file_explorer.png}
	\captionof{figure}{Explorador de arquivos implementação}
	\label{fig:file-explorer}
\end{center}

Dessa forma, o arquivo procurado tem sua probabilidade maximizada pelo circuito, sendo apresentada a distribuição após $n$ medições.

\begin{center}
	\includegraphics[scale=0.6]{AER-file-explorer-hist-new-grover-mapped-rotations.png}
	\captionof{figure}{Explorador de arquivos resultados - Qiskit AER ($shots=1000$)}
	\label{fig:file-explorer-hist}
\end{center}

\subsubsection{Resultados}

Para esse caso hipotético, certamente essa é um das melhores maneiras para fazer buscas dentre todos os arquivos armazenados.\\
Contudo, ao projetar esse modelo para um sistema clássico, tentando tomar proveito da computação quântica, essa não se mostra como a melhor opção. Isso acontece pois, guardar uma Look-Up-Table para os arquivos, e outra para cada ângulo de cada bit-string dentre as $2^{n}$ combinações, pode ser custoso e lento, além de requerer uma hash function com pouca probabilidade de colisão. Para diminuir esse overhead, poderia ser utilizado, simplesmente, o algoritmo de Grover sem maiores alterações, mas ainda assim seria necessário ter mapeado todos os arquivos em disco para a tabela. Assim, tomando como referência sistemas que utilizam o mapeamento de arquivos baseado em árvores ($O(log(n))$), esse método não apresenta ganho algum, além de possuir a probabilidade de não encontrar, ou retornar o arquivo errado.

\begin{center}
	\includegraphics[scale=0.5]{algorithms-finding-comparation.png}
	\captionof{figure}{Comparação algoritmos usados na pesquisa}
	\label{fig:file-explorer-comparation-O}
\end{center}

Sendo assim, os algoritmos apresentados, são as melhores alternativas para serem utilizadas em um sistema que é, principalmente, quântico. Mas para casos de otimização clássica, deve ser utilizado apenas para complexidades $\ge O(n)$.


\subsection{Milhas para Quilômetros} \label{conversion}
O segundo problema testado, foi a conversão de milhas para quilômetros. Essa ideia se deu após a descoberta de um algoritmo capaz de calcular a sequência de Fibonacci usando circuitos quânticos, algoritmo essencial para esse projeto.

\subsubsection{Algoritmos usados}

\subsubsubsection{Algoritmo Quântico de Fibonacci}
A versão quântica usada para calcular Fibonacci foi apresentada em \cite{gilliam2020canonical} e  demonstra que, utilizando um circuito do qual coloca em superposição todas as bit-strings com $n$ qubits, e então realizando operações para remover valores que possuem $1$s consecutivos, é possível encontrar o valor $n$ na sequência.

\begin{center}
	\includegraphics[scale=0.3]{fibonacci-circuit.png}
	\captionof{figure}{Exemplo Algoritmo Quântico de Fibonacci}
	\label{fig:fibonacci-circuit}
\end{center}

\begin{center}
	\includegraphics[scale=0.6]{fibonacci-4.png}
	\captionof{figure}{Resultado Fibonacci - F(4)}
	\label{fig:fibonacci-circuit-result}
\end{center}

Após executar o circuito, é necessário verificar a quantidade de bit-strings únicas que apareceram durante os experimentos. No exemplo em \ref{fig:fibonacci-circuit-result}, foram usados $4$ qubits para calcular $F(4)$. Assim, ao contar as bit-strings, temos $F(4) = 8$, retornando então o quarto valor da sequência (nesse caso, a sequência começa do valor $2$, seguindo dessa forma: $F(1)=2, F(2)=3, F(3)=5, F(4)=8, F(5)=13, F(6)=21, ...$). \\
Com isso, é possível usar esse circuito para computações de $F(n)$ utilizando $n$ qubits para encontrar o valor requisitado nessa mesma posição $n$.

\subsubsubsection{Aproximação de Milhas para Quilômetros usando Fibonacci}

Para aproximar o valor de milhas para quilômetros, podemos utilizar a sequência de Fibonacci com a seguinte relação: $F_{km} = F_{milhas}(n+1)$, sendo aqui $F$ a versão clássica de Fibonacci com $F(1) = 1$ e $F(2) = 2$. Dessa forma, se a posição $n$ é conhecida, valor aproximado em quilômetros será dado em $n+1$.


\begin{table}[!h]
	\begin{center}
		\begin{tabular}{ |c|c| } 
			\hline
			milhas & km \\
			\hline
			1 & 2 \\
			\hline
			2 & 3 \\
			\hline
			3 & 5 \\
			\hline
			5 & 8 \\
			\hline
		\end{tabular}
	\caption{valores aproximados de Milhas para Quilômetros}
	\end{center}
\end{table}

Valores não presentes na sequência, podem ser aproximados repartindo o valor em partes menores. Por exemplo, para transformar $10$ milhas em quilômetros, podemos fazer: $8 + 2 = 10miles \to F(5) + F(2) \to F(5+1) + F(2+1) =  13 + 3 = 16km$, aproximando então do valor mais preciso de $\approx 16.0934$


\subsubsection{Implementação do circuito}
Com essa formulação, o algoritmo final segue esse fluxo:

\begin{algorithm}[H]
	\begin{algorithmic}
		\State{partes = $quebraValor(valorDeEntrada)$}
		\For{parte in partes}
			\State{Aplique o Oracle $F(parte)$}
			\State{Faça as medições nos qubits}
			\State{Reset os qubits usados}
		\EndFor
		\State{verifique o resultado de cada bit-string}
		\State{Multiplique cada resultado com o valor $i$ correspondente}
			
	\end{algorithmic}
	\caption{Algoritmo quântico para a conversão}
	\label{alg:miles-to-km-quantum-algortihm}
\end{algorithm}


Nesse formato, é necessário pré-processamento utilizando um algoritmo clássico para dividir o número em partes menores. Este então, retorna tuplas mapeando a entrada para o valor $n_i$ e a quantidade de vezes que é necessário a sua aplicação $p$, $(n) \to ((n_1, p_1), (n_2, p_2), ...)$.\\
A partir disso, a parte quântica segue com a aplicação do algoritmo de Fibonacci em formato de Oracle no circuito para o valor $n_i$, em seguida as medições nos qubits usados pelo Oracle e por fim o reset deles, seguindo esse ciclo para cada valor $n$.\\
Após terminar, basta pegar os resultados, e, com um pouco de pós-processamento, agrupar as partes e multiplicar pelo seus valores $p$, retornando então o valor aproximado em quilômetros.

\begin{center}
	\includegraphics[scale=0.15]{number_breakdown_circuit.png}
	\captionof{figure}{Circuito de conversão}
	\label{fig:miles-km-circuit}
\end{center}

\subsubsection{Resultados}
Usando esse método, é possível alcançar os valores esperados. Contudo existem alguns pontos que tornam esse método inviável:

\begin{enumerate}

\item{\textbf{Quantidade necessária de medições e tempo de execução}}\\
Para cada medição do circuito, é necessária uma quantidade alta de \emph{shots} (valores entre $5000$ e $10000$ foram testados localmente usando o Qiskit AER e, para os testes no hardware da IBM, foram usados apenas $1000$ por questões de extrema demora e erros durante os experimentos) para alcançar melhores resultados, aumentando também o tempo necessário para finalizar a execução.

\begin{center}
	\includegraphics[scale=0.6]{comparison_miles_to_km.png}
	\captionof{figure}{Comparação tempos de execução}
	\label{fig:comparasion-miles-km-time}
\end{center}

Como mostrado em \ref{fig:comparasion-miles-km-time}, o tempo das versões clássicas, com e sem memoization, possuem tempos praticamente constantes em relação as versões quânticas.


\item{\textbf{Erros}}\\
Como a maioria dos algoritmos Quânticos da era NISQ(noisy intermediate-scale quantum), os erros também estão presentes, e por serem utilizados inúmeros gates multi-qubits, esses erros podem ainda se intensificar de acordo com hardware usado.

\item{\textbf{Imprecisão}}\\
\begin{center}
	\includegraphics[scale=0.4]{miles_to_km_defiance.png}
	\captionof{figure}{Comparação resultados versão clássica e quântica}
	\label{fig:values-miles-km-quantum}
\end{center}

Como mostrado em \ref{fig:values-miles-km-quantum}, valores pequenos possuem uma boa precisão com os números esperados, mas a partir de certo ponto, eles começam a se distanciar e perdem totalmente a precisão.

\item{\textbf{Necessidade de intervenção clássica}}\\
Por requisitar pré e pós processamento clássico e apenas uma pequena parcela ser de fato processamento quântico, a necessidade de utilizar esse algoritmo se reduz a zero. 

\end{enumerate}

Sendo assim, esse algoritmo não consegue se sair bem como a versão clássica, além de ser mais custoso na maioria dos casos. Para evoluir essa implementação, será necessário remodelá-lo para um versão com pouca, ou nenhuma, computação clássica, priorizando a maneira como dados podem ser encodados e transformados no circuito.

\subsection{Torres de Hanoi} \label{hanoi}
Para a criação das torres de Hanoi, foi pensado em uma maneira de encodar a posição dos discos na torre utilizando seus valores binários e o Phase Oracle como meio de armazenamento.

\subsubsection{Implementação}
Para esse projeto, são necessários $(\floor{\log_2{x}} + 1) * 3$ qubits, sendo $x$ o número de discos. Estes seguem a ordem $\ket{t_{n-1} t_{n-2} ... t_0}\ket{a_{n-1} a_{n-2} ... a_0}\ket{s_{n-1} s_{n-2} ... s_0}$, sendo $s$,$a$,$t$ a primeira, segunda e última torre respectivamente, e $n = {{n \space qubits} \over 3}$.\\
Com essa configuração, os números de $1$ à $x$ são codificados em seu formato binário nos qubits $s$, utilizando a fase global $\pi$. Em seguida, são realizadas operações de $swap$ bit-a-bit para mover os valores dos $n$ qubits menos significativos para os $n$ mais significativos.\\
Para realizar essas operações, é necessário pré-calcular, classicamente, a sequência de movimentos usados  \cite{ldiaandr_2021_tower} \cite{diptokarmakar47_2019_how} \cite{a2020_towers}  \cite{geeksforgeeks_2014_program}. Dessa forma, essa versão quântica age como um jogador com uma lista de passos a serem seguidos, executando-os um-a-um.

\begin{center}
	\includegraphics[scale=0.3]{hanoi_3_discs.png}
	\captionof{figure}{Torre de Hanoi com 3 discos}
	\label{fig:hanoi}
\end{center}

Nesse circuito, pode-se utilizar algoritmos adicionar, como o algoritmo de Grover, para verificar o resultado, ou executar outras operações nos valores.

\begin{center}
	\includegraphics[scale=0.5]{result_hanoi_3_discs.png}
	\captionof{figure}{Resultado usando Grover - Torre de Hanoi com 3 discos}
	\label{fig:hanoi-result}
\end{center}

Em \ref{fig:hanoi-result}, os $3$ maiores resultados obtidos são as bit-strings com $01$, $10$ e $11$ nos bits mais significativos. Sendo assim, o resultado esperado para uma torre com 3 discos, foi atingido.

\subsubsection{Resultados}
Nessa versão, é seguida a mesma sequência do algoritmo clássico, necessitando, inclusive, de pré-processamento para conseguir a sequência de ações.\\
Em uma versão clássica, o movimento de retirar um disco de uma torre e move-lo para a próxima requer também esse pré-processamento, podendo ser realizado um-a-um ou tudo de uma vez antes da partida. Dessa forma, a versão clássica e quântica se igualam, não tendo ganhos ou perdas expressivas.

\subsection{Buckshot Roulette} \label{buckshot}
\emph{Buckshot Roulette} é um jogo de computador feito pelo desenvolvedor \href{https://mikeklubnika.itch.io/}{Mike Klubnika}, tomando como base a premissa de reinventar a infame roleta russa. No jogo, você é desafiado por um demônio (dealer), e caso você ganhe, uma recompensa lhe será dado, caso contrário o jogo reinicia e você pode tentar novamente.\\
Nesse projeto, foi tomado como objetivo analisar a primeira rodado do jogo e tentar encontrar a melhor estratégia para maximizar os ganhos do jogador. O motivo da escolha da primeira rodada se dá pela sua simplicidade, sendo direto ao ponto, sem power-ups ou fatores que dificultariam as simulações, mas, ainda assim, mantendo a essência do jogo.

\subsubsection{Dinâmica}
Na rodada, são colocadas $2$ balas falsas e $1$ bala verdadeira na arma, sendo o player o primeiro a jogar. Ambos os jogadores podem escolher entre atirar em si mesmo, ou em seu oponente. Assim, a próxima ação é estritamente depende das probabilidades de ser uma bala real ou falsa. A partir dai, a dinâmica funciona da seguinte forma: 

\begin{algorithm}[H]
	\begin{algorithmic}
		\If{jogador escolhe atirar no dealer}
			\If{bala for real}
				\State{Jogador ganha a rodada}
			\Else
				\State{Dealer joga a próxima}
			\EndIf
		\Else
			\If{bala for real}
				\State{Jogador perde}
			\Else
				\State{Player joga a próxima}
			\EndIf
		\EndIf

	\end{algorithmic}
	\caption{Possíveis jogadas}
	\label{alg:buckshot-roulette}
\end{algorithm}

Essa dinâmica se repete a cada jogada, sendo válida tanto para o dealer, como para o player.


\subsubsection{Versão clássica}
Para entender melhor a dinâmica, é possível representar cada ação e suas consequências em formato de árvore. Dessa forma, cada jogada leva a partida para mais próximo do fim.


\begin{center}
	\includegraphics[scale=0.2]{buckshot-roulette-diagram.png}
	\captionof{figure}{Buckshot Roulette diagrama de árvore}
	\label{fig:classical-model-bckr}
\end{center}

Nessa estrutura, é previsto que o jogador seja um agente racional, e o dealer uma máquina com ações aleatórias. Assim, o jogador sempre visa o seu próprio benefício, enquanto o dealer age pela sorte.Tal comportamento pode ser visto nas folhas da árvore do qual, sempre que o player é o próximo jogador, sua ação é apenas atirar no adversário, enquanto o dealer ainda possui a possibilidade de entregar o jogo atirando em si próprio, mesmo havendo apenas uma bala na arma e, pela lógica do jogo, ser uma bala verdadeira.\\
Seguindo essa estrutura, podemos simular os possíveis caminhos e verificar a melhor estratégia.

\begin{center}
	\includegraphics[scale=0.6]{optimal_player_strategy.png}
	\captionof{figure}{Buckshot Roulette clássico - melhor estratégia}
	\label{fig:classical-model-bckr-optimal-strategy}
\end{center}

Após testar os caminhos possíveis, o melhor resultado obtido foi esse apresentado acima em \ref{fig:classical-model-bckr-optimal-strategy}. Com um pouco de investigação, foi possível entender que essa estratégia se baseia no jogador começar atirando no dealer. Isso acontece, pois, ao seguir tal caminho, ele tem uma chance a menos de perder a rodada ao atirar em si mesmo logo no começo da partida.

\begin{table}[!h]
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			rodada & ação & resultado da ação & resultado da partida \\
			\hline
			1 & player atira no dealer  & real & player ganha\\
			\hline
			1 & player atira no dealer  & fake & -\\
			\hline
			2 & dealer atira no player  & real & dealer ganha\\
			\hline
			2 & dealer atira no player  & fake & -\\
			\hline
			2 & dealer atira nele mesmo  & real & player ganha\\
			\hline
			2 & dealer atira nele mesmo  & fake & -\\
			\hline
			3 & player atira no dealer  & real & player ganha\\
			\hline
			3 & dealer atira no player & real & dealer ganha\\
			\hline
			3 & dealer atira nele mesmo  & real & player ganha\\
			\hline
		\end{tabular}
		\caption{melhor estratégia - possíveis resultados}
	\end{center}
\end{table}

\subsubsection{Versão quântica}
Para a versão quântica, um circuito foi modelado imitando o funcionamento do game. Nesse algoritmo, um Oracle foi usado para cada jogador, implementando internamente sua estratégia.

\begin{center}
	\includegraphics[scale=0.3]{quantum_buckshot_roulette.png}
	\captionof{figure}{Circuito para o Buckshot Roulette}
	\label{fig:bckr-circuit}
\end{center}

Além disso, para encontrar a estratégia, foram inseridos dois parâmetros dentro do Oracle do player, sendo possível configurar qualquer valor $\theta$ e $\phi$ para modificar a rotação na Bloch Sphere.\\
Após verificar os possíveis valores, a rotação que entregou o melhor resultado foi $\theta\approx 3.0853981633974477, \phi\approx3.7853981633974474$ radianos. Usando essa estratégia, os resultados foram semelhantes a versão clássica.

\begin{center}
	\includegraphics[scale=0.6]{final_buckshot_roulette_quantum_optimal_strategy.png}
	\captionof{figure}{Resultado Buckshot Roulette quântico - Qiskit AER}
	\label{fig:bckr-circuit-result}
\end{center}

Observando a Bloch Sphere do estado gerado por essa rotação, é possível ver também que a estratégia se aproxima da versão clássica, com o player preferindo atirar no dealer a maior parte do tempo (o valor $1$ representa atirar no outro jogador e $0$ em si mesmo).

\begin{center}
	\includegraphics[scale=0.6]{player_optimal_strategy_bloch.png}
	\captionof{figure}{Melhor estratégia Buckshot Roulette quântico - Bloch Sphere}
	\label{fig:bckr-bloch-sphere-best-strategy}
\end{center}

Como uma última nota sobre o circuito, no exemplo \ref{fig:bckr-circuit-result}, o total de partidas ganhas por cada jogador não chega ao total jogado (nesse caso $1000$ partidas foram simuladas). Isso acontece devido ao design do circuito, o qual não é possível verificar a jogada do player anterior, acarretando na continuação do jogo mesmo que um dos players já tenha perdido, o que cria a necessidade do uso de pós processamento para limpar os resultados inválidos.

\subsubsection{Conclusões}
Para esse problema, não há uma competição certa entre as duas versões, já que uma é diretamente inspirada na outra. Contudo, a versão quântica possui ainda a possibilidade de explorar mais valores do que a versão clássica, deixando o player mais aberto a escolha de novas estratégias, o que pode ser visto como um ponto a favor da versão quântica.\\
Em suma, ambos as simulações atingiram o mesmo resultado e foi demonstrado que é possível usar o quantum Oracle como uma representação de um player dentro do circuito.

\subsection{QRAM} \label{qram}
Por fim, o último projeto realizado foi o de uma \emph{QRAM} utilizando os Oracles. Nessa versão, foi testado a criação de \emph{QROMs} (com dados estáticos dentro), e uma possível maneira de utilizar uma QRAM hábil para escrita.\\
Neste projeto, foi tido como objetivo o armazenamento de estados quânticos (superposições), e não apenas de bit-strings clássicas. Isso pois, para garantir a real eficiência da computação quântica, a superposição é indispensável, e seu armazenamento pode ser um ponto chave para algoritmos melhores.

\subsubsection{QROM}
Para a QROM, são utilizados $n$ qubits para o barramento de endereços e $m$ qubits para a o barramento de dados, sem a necessidade desses valores estarem correlacionados, podendo assim ser utilizado, por exemplo, $n=3; m=10$. Nessa estrutura, podemos mapear diversas superposições diferentes e aplicá-las quando certo endereço for chamado. Sendo assim, o algoritmo armazena os valores a partir da configuração de gates controlados interiores ao Oracle, criando uma superposição apenas quando certo valor de entrada é inserido, seguindo o formato: ${\ket{0}^{\otimes m}} {\ket{a_{n-1} a_{n-2} ... a_0}}$.

\begin{center}
	\includegraphics[scale=0.5]{qrom_1.png}
	\captionof{figure}{Exemplo circuito - QROM}
	\label{fig:qrom}
\end{center}


Em \ref{fig:qrom}, $q_{0}$ age como o barramento de endereços, enquanto $q_{1}$ como o barramento de dados. Aqui configuramos para mapear o endereço $0 \to RY({\pi\over{3}})$ e $1 \to H$. Sendo assim, para $n$ qubits no barramento de endereços é possível mapear para $2^{n}$ estados, e com os $m$ qubits é possível criar estados mais complexos aumentando sua quantidade e utilizando outros gates acionados para um mesmo endereço. \\
A partir da abstração desse circuito para um Oracle,é possível utilizar a QROM em um circuito maior, chamando-o novamente sempre que for necessário um certo estado. Além disso, no formato de Oracle, há a possibilidade de colocar os endereços em superposição e ter uma mistura de estados na saída.

\begin{center}
	\includegraphics[scale=0.5]{qrom_1_usage.png}
	\captionof{figure}{Exemplo circuito usando a QROM com endereços em superposição}
	\label{fig:qrom-usage}
\end{center}

Nesse exemplo \ref{fig:qrom-usage}, os endereços são colocados em superposição no qubit \emph{addr} e assim os estados em internos do Oracle são colocados em uma sobreposição de $50-50$ no qubit \emph{out}. Com isso, pode-se aproveitar do resultado de \emph{out} em outros qubits, como nesse caso o qubit \emph{q}.\\
Contudo, devido ao no-cloning-theorem, não é possível copiar esse estado para outro qubit alvo. Sendo assim, não é possível ter dois qubits com o mesmo estado a partir daquele armazenado, podemos apenas pegar o resultado de uma superposição e utilizar o valor binário como trigger para outra operação.\\
Uma opção para solucionar isso, é utilizar o teleporte quântico, destruindo assim o estado interno do Oracle e movendo-o para outro qubit desejado.

\subsubsection{QRAM}
Para criar uma QRAM com a possibilidade de escrita, o teleporte quântico, já citado anteriormente, é um caminho para isso. Com ele, podemos ter $n$ qubits, sendo cada qubit um endereço único, e utilizar do teleporte para mover um estado que estava no circuito, para o domínio da QRAM.

 \begin{center}
 	\includegraphics[scale=0.4]{qram.png}
 	\captionof{figure}{Exemplo circuito - QRAM}
 	\label{fig:qram}
 \end{center}

Aqui, os $n$ qubits agem tanto como endereços quanto dados (qubits \emph{data}). Além disso, são necessários mais $n$ qubits para o teleporte (qubits \emph{t}).\\
Com isso, é possível ver que o circuito cresce de forma linear a medida que mais endereços são requisitados, sendo assim $O(2*n)$ em relação à quantidade de qubits total.\\
Na configuração acima \ref{fig:qram}, é possível sobre-escrever valores, assim como interferir com outras superposições apenas teleportando novos valores para o qubit $i$. Dessa forma, podemos criar uma memória menor e, conforme necessário, remover e adicionar outros valores.

\subsubsection{Conclusões}
Com esse projeto, e com a literatura usada \cite{jaques2023qram}\cite{Giovannetti_2008}, é possível entender que criar versões quânticas de memória é uma tarefa desafiadora, e ainda não é possível tomar proveito de todo o seu potencial usando as superposições e estados de outras bases a não ser a base computacional $({0,1})$. Fatores como, complexidade de mapear dados, complexidade de utilizar a memória (já que é necessário reaplica-lá toda vez que for requisitado seu uso), no-cloning-theorem, decorrência, etc. Influenciam diretamente na possibilidade de sua criação.Mesmo sendo possível implementar pequenos circuitos que agem como memória, como os mostrados aqui, ainda não é usual e muito menos universal para qualquer tipo de máquina quântica.\\
Além disso, por esses fatores, a QRAM, pode dificultar a execução de múltiplas tarefas, uma vez que o valor presente nela não pode ser copiado, e ao move-lo para outro qubit, o valor anterior da QRAM é completamente destruído.\\
Como mostrado na literatura, para resolver esses problemas, o melhor approach para a sua implementação, é a utilização de um hardware especifico para essa finalidade, sem a intervenção de circuitos quânticos.\\ 
Em suma, mesmo sendo possível criar pequenos circuitos para implementar uma memória, seu uso está longe de se comparar as versões clássicas.

\subsection{Conclusão}
Perante o exposto, foi evidenciado que a computação quântica ainda tem muito potencial. No entanto, é possível ver que certos fatores, e a falta de alguns recursos, prejudicam o seu uso no momento.\\
Como já mostrado pelas inúmeras pesquisas em áreas como, química, machine learning, criptografia, otimização, etc. A computação quântica pode, num futuro próximo, ser um ponto crucial para conseguir resultados mais precisos e, em certos casos, em menor tempo.\\
No entanto, na era NISQ, para conseguir utilizar todo seu potencial, é necessário ter em conjunto máquinas clássicas para pré e/ou pós processamento, seja para executar alguma tarefa computacionalmente custosa para um computador quântico, ou para o uso de algoritmos de detecção e correção de erros. Como demonstrado aqui, ao utilizar esse conjunto, é possível ter o melhor dos dois mundos, mesmo que na maioria do casos, esse formato de implementação não se sobressaí as versões já utilizadas classicamente, com o tempo e o aperfeiçoamento das técnicas e do hardware darão uma abrangência maior aos usos da computação quântica.\\
Em resumo, é possível tirar proveito da computação quântica para problemas que conhecemos classicamente. No entanto, é necessário averiguar se há algum fator quântico que pode ser explorado para conseguir alguma vantagem perante a sua versão clássica, se houver, é necessário verificar também se todas as tarefas são mais vantajosas ao serem implementadas usando o algoritmo quântico, ou se ao explorar uma abordagem híbrida os ganhos podem ser maiores.

\nocite{SOARE2009368}
\nocite{odonnell_2015_lecture}
\nocite{bacon_2006_cse}
\nocite{lipics_stacs}
\nocite{odonnell_2015_lecture_2}
\nocite{brodkorb_2019_the}
\nocite{amreen_oracle}
\nocite{kalyanasyndaram_2021_mod04lec23}
\nocite{davis_2006_turing}
\nocite{viswanathan_2013_reductions}
\nocite{Fan_2007}
\nocite{cryptoeprint:2020/1270}
\nocite{buhrman1998quantum}
\nocite{sanchezrivero2023initial}
\nocite{gilliam2020canonical}
\nocite{Kashefi_2002}
\nocite{e21080800}
\nocite{Zeng_2014}
\nocite{atici2004comparative}
\nocite{sundarappan_2022_how}
\nocite{dai_view}
\nocite{sep-game-theory}
\nocite{Giovannetti_2008}
\nocite{jaques2023qram}
\nocite{PythonEWL2022}
\nocite{frackiewicz2011application}
\nocite{Eisert_1999}
\nocite{usman_2019_kilometres}
\nocite{ldiaandr_2021_tower}
\nocite{diptokarmakar47_2019_how}
\nocite{a2020_towers}
\nocite{geeksforgeeks_2014_program}
\nocite{khan_2021_quantum}
\nocite{legn_2022_dilemma}
\nocite{siegelwax_2022_quantum}
\nocite{landi_density}
\nocite{bacon_2006_cse}
\nocite{vijayakrishnan_2019_role}
\nocite{python_scientific}
\nocite{scipyoptimizeminimize_scalar}
\nocite{davis_optimization}
\nocite{scipyoptimizeminimize}



\bibliographystyle{unsrt}
\bibliography{references}


\end{document}
