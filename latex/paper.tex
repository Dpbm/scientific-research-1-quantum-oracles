\documentclass{article}
\usepackage{arxiv}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}    
\usepackage{hyperref}      
\usepackage{url}            
\usepackage{booktabs}       
\usepackage{amsfonts}       
\usepackage{nicefrac}       
\usepackage{microtype}      
\usepackage{cleveref}       
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{doi}
%\usepackage{caption}
\usepackage{braket}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{mathtools}
\usepackage{titlesec}
\usepackage[rightcaption]{sidecap}
\usepackage{wrapfig}
\usepackage{subfig}


\captionsetup[table]{skip=5pt}

\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\makeatletter
\renewcommand\subsubsubsection{\@startsection{paragraph}{4}{\z@}{-2.5ex\@plus -1ex \@minus -.25ex}{1.25ex \@plus .25ex}{\normalfont\normalsize\bfseries}}
\newcommand\subsubsubsubsection{\@startsection{subparagraph}{5}{\z@}{-2.5ex\@plus -1ex \@minus -.25ex}{1.25ex \@plus .25ex}{\normalfont\normalsize\bfseries}}
\makeatother

\title{Quantum Oracles - How to Transform Classical Problems into Quantum ones}

\date{\today}

\author{ 
	\href{https://orcid.org/0009-0008-9134-5974}{\includegraphics[scale=0.06]{orcid.pdf}\hspace{1mm}Alexandre Silva}\\
	Computer Science\\
	UNIVEM - Centro Universitário Eurípides de Marília\\
	\And
	\href{http://lattes.cnpq.br/5170103189904688}{\hspace{1mm}Luis Hilário Tobler Garcia} \\
	Computer Science\\
	UNIVEM - Centro Universitário Eurípides de Marília\\
	\And
	\href{http://lattes.cnpq.br/7265559606596355}{\hspace{1mm}Maúricio Duarte} \\
	Information Technology \\
	Fatec Garça – Deputado Julio Julinho Marcondes de Moura\\
}

\graphicspath{ {../images/} }

\renewcommand{\headeright}{}
\renewcommand{\undertitle}{}
\renewcommand{\shorttitle}{}


\hypersetup{
	pdftitle={Quantum Oracles - Como transformar problemas classicos em quanticos},
	pdfsubject={quantum computing, computer science, ciências da computação, computação quântica, algoritmos, algorithms, problem solving, problems, solução de problemas, problemas},
	pdfauthor={Alexandre Silva},
	pdfkeywords={quantum oracles, quantum, quantum computing, algoritmos, algorithms, problems, problemas},
}

\begin{document}

\maketitle

\begin{abstract}
	Using quantum oracles and other effects, like superposition, \emph{5 mini-projects} were done. The main goal of these projects was to answer if it's possible to bring some problems to the quantum realm and if such translation worth it. After finishing the tests, it was possible to see that, some of the implementations show descent results. However, classical computing is still a fundamental part of quantum algorithms.
\end{abstract}


\section{Introduction}
Now days, isn't difficult to hear someone talking about quantum computers, and how these machines will change the world. Nonetheless, the major fraction of these comments come from extrapolations and science fiction present in popular movies and series around the world. In this paper, I'm going to show that quantum computing it's not a magical trick to solve everything, but a tool for solving a distinct group of problems.\\
To do that, \emph{5 mini-projects} were implemented using \href{https://www.ibm.com/quantum/qiskit}{qiskit}, an open source framework from \href{https://www.ibm.com/}{IBM}, exploiting quantum effects and using classical/quantum algorithms to reach the expected outcomes. After that, the results will be here compared with their classical counterparts.
Such mini-projects are the following: Quantum File explorer\ref{file-explorer}, miles to kilometers conversion\ref{conversion}, Hanoi towers\ref{hanoi}, Buckshot Roulette \ref{buckshot} and QRAM \ref{qram}. All these implementations can be found at \href{https://github.com/Dpbm/scientific-initiation-1-quantum-oracles}{my GitHub repository}.

\section{Oracles}
Based on the idea of \emph{Oracle Turing Machines} \cite{SOARE2009368}\cite{amreen_oracle}\cite{kalyanasyndaram_2021_mod04lec23}\cite{e21080800}, the Oracles are mathematical modeling tools, used to abstract outlying parts of an algorithms into a black-box, making the algorithm analysis much easier. These machines could also be seen as a function, getting an input $x$ e returning $f(x)$ with time-complexity $O(1)$. Because of these unreachable characteristics for real life, this model can't be implemented, being used only for formal description of decision problems.\\
However, in quantum computing, it's possible to implement something similar to that, taking advantage of your inner structure and quantum effects to gain a \emph{Speed-up} relative to its classical counterparts, such Speed-up can be seen, for example, in the Deutsch–Jozsa algorithm \cite{Fan_2007}. Furthermore, the Quantum Oracles have a fundamental role determining the circuit complexity. Some approaches for that are: \emph{depth}, calculating the longest path in the circuit that some information must pass through and \emph{gate counting}, summing up how many gates were applied in the final circuit. Nevertheless, these approaches are very dependent of the \emph{QPU} topology, differing from each \emph{backend} used during the \emph{transpilation} process. To solve this problem, a well-known technique is to pack some parts of the circuit into Oracles, and then describing the complexity based on how many times they are called, it's also known as \emph{query complexity} \cite{odonnell_2015_lecture} \cite{e21080800}.

\subsection{Types of Oracles}
Using the base description of Quantum Oracles, we can classify them based on their structures and how the data is processed.

\subsubsection{Phase Oracle}
The Phase Oracle, is the most well-known format. Some Algorithms, like Deutsch–Jozsa, Grover, Simon and Bernstein–Vazirani, use it to take advantage over Classical approaches.

\subsubsubsection{Default Behavior}
As its main characteristic, the Phase Oracle adds a global phase to the circuit, using quantum effects like \emph{Phase Kickback} (basically the phase pass all the way through CNOT's target and is applied in the control Qubit), to change values in superposition.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{phase_oracle_1.png}
	\caption{Phase Oracle using Phase-Kickback Example}
	\label{fig:phase-oracle-1}
\end{figure}

In the Figure \ref{fig:phase-oracle-1}, a $\pi$ phase was added in the auxiliary Qubit ($q3$), taking advantage of the phase $\ket{-}$, which will be the responsible to modify the values in the unitary matrix. In this setup, the $CNOT$ gates act slightly different from its default behavior, this way, the gate invert the value of the target Qubit and, due the $\pi$ phase, it also acts like a $Z$ gate applied in the control Qubit. So, after applying $CNOT\ket{-}\ket{+}$ (little-endian), the state becomes ${\frac{1}{\sqrt{2}}}{(\ket{0}\ket{-} - \ket{1}\ket{-})}$, and after removing the superposition, the final state is: ${\frac{1}{\sqrt{2}}}{(\ket{+}\ket{1} - \ket{-}\ket{1})}$. This way, the control Qubit is changed due the \emph{Phase Kickback} and its state is flipped from $\ket{0}$ to $\ket{1}$. Taking this effect as and advantage, we can use it to encode some binary values inside these oracles and use them to do some calculations.

\subsubsubsection{Minimal Oracle Version}

Furthermore, There's another layout possible for implementing a Phase Oracle. Once this one only applies a phase in some bit-strings, the auxiliary Qubit can be removed, and the phase can be provided by $CZ$ gates (or any other gate which can apply a phase for certain bit-strings). Doing that, it's possible to create a phase oracle keep its unitary and reversible nature, in the format of a minimal Oracle.

\newpage

\begin{figure}
	\centering
	\subfloat[\centering Phase Oracle - Minimal Oracle Layout Example]{\includegraphics[width=5cm]{phase_oracle_2.png} \label{fig:phase-oracle-2}}
	\subfloat[\centering Figure \ref{fig:phase-oracle-2} Resulting Unitary Matrix]{\includegraphics[width=5cm]{phase_oracle_unitary.png} \label{fig:phase-oracle-unitary}}
	\caption{Phase Oracle Minimal Version}
	\label{fig:phase-oracle-minimal}
\end{figure}

In the example above \ref{fig:phase-oracle-minimal}, a $MCP$ gate was applied adding a $\pi$ phase and another two $X$ gates were used to invert the Qubits we want to have the value $0$ as a trigger for the $MCP$ phase application. Following the little-endian format the final encoded bit-string is: $011_{2}$ or $3_{10}$.

Looking at its unitary matrix \ref{fig:phase-oracle-unitary}, it's possible to see the $8\times8$ identity matrix with a $-1$ value in the column relative to the bit-string $011_{2}$, representing the encoded value.

\subsubsection{Boolean Oracle}

The Boolean Oracle has a similar structure with the Phase Oracle. However, this time a phase isn't applied, acting this way a regular boolean function, mapping inputs to outputs.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{balanced-oracle.png}
	\caption{Boolean Oracle Example}
	\label{fig:boolean-oracle}
\end{figure}

The example in the Figure \ref{fig:boolean-oracle}, is a well-known balanced Oracle for the Deutsch-Jozsa's algorithm. Nevertheless, to implement it, the Oracle must be transformed into a Phase Oracle.

\subsubsection{Minimal Oracle}
As previously mentioned, the Minimal Oracle is a function which its essence is unitary and reversible, so no additional Qubits are required. Therefore, this format can be either Boolean or Phase Oracle, depending on its implementation.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{minimal-oracle.png}
	\caption{Boolean Minimal Oracle example}
	\label{fig:minimal-oracle}
\end{figure}

The example \ref{fig:minimal-oracle} shows an Boolean Oracle which two $SWAP$ gates were used to invert the Qubits values order. Doing this way, the final matrix keeps its unitary and reversible properties, once the  $SWAP$ gates act in both Qubits together, mirroring its action.


\subsubsection{QFT(Quantum Fourier Transform)}
The QFT is, in a nutshell, a quantum algorithm based on the Discrete Fourier Transform, used for quantum states period finding, projecting values from the computational basis onto the $X$ basis (also know as Fourier basis).

Even though it's an algorithm by itself, its application is done in the format of Oracles in quantum circuits.


\begin{figure}[h]
	\centering
	\subfloat[\centering QFT Oracle example]{\includegraphics[scale=0.3]{QFT_1.png} \label{fig:QFT}}
	\subfloat[\centering Values Mapped onto Fourier basis example (quantum state $\ket{000}$)]{\includegraphics[scale=0.2]{QFT_1_bloch.png} \label{fig:QFT-bloch}}
	\caption{QFT Oracle}
	\label{fig:QFT-oracle}
\end{figure}


\subsubsection{Other kinds of Oracles}
In addition to the oracles mentioned above, it's possible come across with different mentions of Oracles, like the Simons's, Deutsch-Jozsa's, etc. However, these are just implementations of models already shown in this paper. Also, the most relevant for the following projects are the Phase and Boolean ones, due that, there's no use to keep discussing about many others sub-categories of Oracles here.

\section{Development}


\subsection{File Explorer} \label{file-explorer}
Imagine a quantum computer, but instead of one of those we already have in real life, imagine a different kind, very similar to those we have at home, with a quantum operational system, quantum files, etc. This imaginary version could be thought as a hybrid computer as well, taking advantage of both quantum and classical capabilities. Using this idea, the first project implements a file explorer for this ideal system.

\newpage

\subsubsection{Algorithms Used}

\subsubsubsection{Grover}
The Standard algorithm for search problems is the Grover's algorithm. This one, realizes searches on unsorted "databases" (bit-string in this case) with $O(\sqrt{2^n})$, being $n$ the number of Qubits. Its tenets are based on amplitude amplification, using a Phase Oracle to mark some bit-strings and then using a Diffuser to amplify the probability to find these values after measuring it.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.25]{Grover.png}
	\caption{Example Grover's algorithm with $3$ Qubits}
	\label{fig:grover-default-circuit}
\end{figure}

For building the circuit, is needed a joint of $Oracle + Diffuser$ applied $k$ time, which $k \approx { {\frac{\pi}{4 \sqrt{\frac{a}{2^n}}}} - {\frac{1}{2}}  }$, being $a$ the number of values marked by the Oracle. Once we want to find just a single file, the use of this relation is not required, being need to apply the algorithm once to find the bit-string.

Even this being the best option for bit-string finding, in this project different rotations were tested trying to find a better superposition which increases the chances to find the value we want.

\begin{SCfigure}[0.6][h]
	\caption{Comparing the Standard Grover's algorithm with the version modifying the rotation angles $[0, 2\pi]$ for each 4 bits bit-string}
	\includegraphics[width=8cm]{improvement-grover-algorithm-4bits-0-to-2pi.png}
	\label{fig:best-angle-grover}
\end{SCfigure}

\newpage

Using specific rotations for each bit-string, it's possible to improve the outcomes, and even stand out the default rotation.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{new-grover-test-different-bit-strings-with-optimal-angles.png}
	\caption{Test Using the best angles of each bit-string in different ones}
	\label{fig:best-angles-diff-bit-strings-grover}
\end{figure}

However, using the best angle of a distinct bit-string as the source of superposition in the algorithm, isn't enough to overcome the classical Grover implementation, and also the probability distribution becomes irregular. So, for a general purpose implementation, the default rotation is the best one for the most part of the cases. This behavior is even weird with $2$ Qubits, being the $H$ gate rotation the best ever for that.


\begin{figure}[h]
	\centering
	\subfloat[\centering Results for Grover with 2 Qubits (default rotation)]{\includegraphics[scale=0.3]{classical_grover_for_1_bit_strings_l2_outcomes.png} \label{fig:l2-grover-classical-outcomes}}
	\subfloat[\centering Results for Grover with 2 Qubits (modified rotation)]{\includegraphics[scale=0.3]{new_grover_for_1_bit_strings_l2_outcomes.png} \label{fig:l2-grover-new-outcomes}}
	\caption{Comparing Grover with 2 qubits using the default and modified rotation}
	\label{fig:comparing-grover-2-qubits}
\end{figure}

For our purpose in this project, the hybrid approach was used. So during the circuit setup, the searched value pass through a Hash-Table will optimal angles. This way, the algorithm can achieve better outcomes at the end of the execution, finding, this way, the file we want. 

\subsubsubsection{Sets Difference}
Overlapping two distinct Phase Oracles, each one with a range of values encoded. The remaining Phases, are the difference of the sets encoded by them \cite{sanchezrivero2023initial}.

\newpage

\begin{figure}[h]
	\centering
	\subfloat[\centering Sets Difference Algorithm Example]{\includegraphics[scale=0.4]{less_than.png} \label{fig:less-than-circuit}}
	\subfloat[\centering Unitary After applying the Sets Difference algorithm]{\includegraphics[scale=0.5]{less_than_unitary.png} \label{fig:less-than-circuit-unitary}}
	\caption{Sets Difference example}
	\label{fig:sets-diff-example}
\end{figure}


In the last example \ref{fig:less-than-circuit}, the set $\{000, 001, 010, 0110\}$ was encoded in the first Oracle and $\{000, 001, 010, 011, 100, 101\}$ in the second one.

After Overlapping the phases  \ref{fig:less-than-circuit-unitary}, only the values $\{100, 101\}$ keep the $-1$ value. This way, we can do the set operation just applying some oracles with the values range we want.

\subsubsection{Final Solution}


As a solution for this problem, a hash function was made, mapping the path of some file $p$ to a specific bit-string $b$, $F: p \to b$. With this function, we can use a set returned values and encode them into a Phase Oracle, creating a sort of quantum Look-Up-Table for files in that machine. Moreover, a second Oracle containing all the bit-strings, with the exception of the searched one, is applied for difference of sets algorithm, this way the phases will be overlapped, and only the one we want will pass to the Grover's algorithm.


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{sets-difference-look-up-table-oracle.png}
	\caption{Look-up-Tables applied}
	\label{fig:luts}
\end{figure}


Finally, the modified version of the Grover's algorithm is applied.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{improved_file_explorer.png}
	\caption{File explorer final circuit}
	\label{fig:file-explorer}
\end{figure}

This setup, maximizes the probability to find the queried file, presenting the following distribution after $1000$ shots.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{AER-file-explorer-hist-new-grover-mapped-rotations.png}
	\caption{ File Explorer Results after running with Qiskit-AER}
	\label{fig:file-explorer-hist}
\end{figure}


\subsubsection{Results}

For this specific ideal case, it is, probably, one of the best known ways to do the search between "quantum files".

However, it's not the best alternative as a way to speed-up classical searches. It happens because storing a large Look-Up-Table for encoded files and another one for keeping track of each optimal angle for every bit-string contained between $2^n$ combinations, could be really costly and slow. Also, it would be required a hash function with a tiny probability of collision.

An alternative for that could be using the standard Grover's algorithm, but it still the need to encode the hard drive files to a big table. Also, comparing the classical tree approach with Grover's, their worst cases scenarios are $O(log(n))$ and $O(\sqrt{n})$, which implies that the first one still faster than the later. As a last point, the quantum version for this problem, could present the wrong file after searching due errors and the quantum randomness.

Keeping that in mind, the final algorithm is a right choice for a quantum system as describe at the beginning of this section, but it can't overcome the best algorithm in a classical computer. 



\subsection{Miles to Kilometers Conversion} \label{conversion}

The second problem that was tested here, was the conversion from miles to kilometers. This idea came out after finding a quantum algorithm capable of calculate the Fibonacci sequence, which is an essential piece for this very project.
 
\subsubsection{Used Algorithms}

\subsubsubsection{Quantum Fibonacci}

The quantum version of Fibonacci was presented in \cite{gilliam2020canonical}. This paper shows that, using a quantum circuit with all bit-string in superposition, and then apply  controlled rotations to remove values that contains consecutive ones, is possible to approximate the result of the \textit{n}-th Fibonacci sequence value.

\newpage


\begin{figure}
	\centering
	\includegraphics[scale=0.3]{fibonacci-circuit.png}
	\caption{Quantum Fibonacci Example}
	\label{fig:fibonacci-circuit}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[scale=0.4]{fibonacci-4.png}
	\caption{Quantum Fibonacci result - F(4)}
	\label{fig:fibonacci-circuit-result}
\end{figure}

After running the circuit $k$ times, the amount of unique bit-string that appeared during the experiment represent the \textit{n}-th Fibonacci value, which $n$ is the total of Qubits were used in the circuit. So, for the example \ref{fig:fibonacci-circuit} above, the position $n$ we want, is $4$, and the result after counting the bars of which values are $\neq 0$ give us the result of $F(4) = 8$.

It may seem wrong, however, the quantum setup differ slightly from the classical one, once the first value is $2$ instead of $1$, this way, the sequence is: $F(1)=2, F(2)=3, F(3)=5, F(4)=8, F(5)=13, F(6)=21, ...$, which implies that it worked for this example.


\subsubsubsection{Approximating Miles to Kilometers}

To approximate the value from miles to kilometers, an old approach for that is using the Fibonacci sequence. This method, uses the relation $F_{km} = F_{milhas}(n+1)$, which $F$ is the classical Fibonacci algorithm ($F(1) = 1$ and $F(2) = 2$), and $n$ is a known position in this very sequence. Following this equation, the relative kilometers values will be given in the next \textit{n} ($n+1$). 

\begin{table}[h]
	\begin{center}
		\begin{tabular}{ |c|c|c| } 
			\hline
			miles & Km & Real(Km) value\\
			\hline
			1 & 2 & 1.60934\\
			\hline
			2 & 3 & 3.21869\\
			\hline
			3 & 5 & 4.82803\\
			\hline
			5 & 8 & 8.04672\\
			\hline
		\end{tabular}
	\caption{Approximated miles-Km values}
	\end{center}
\end{table}

\newpage

For values that aren't present in the sequence, they can be generated combining multiple values which are there. For example, to transform $10$ miles to kilometers, we could use the values $8$ and $2$, which are known in the sequence, and then used the previous cited method for each part. So, for this example, $8 = F(5)$ and $2 = F(2)$, so $F(5 + 1) + F(2 + 1) = F(6) + F(3) = 13 + 3 = 16Km$ giving a close value of $\approx 16.0934Km$.


\subsubsection{Implementation}

Using the formulation above, the final algorithm takes place using a Hybrid approach, following the structure bellow:

\begin{algorithm}[h]
	\begin{algorithmic}
		\State{parts = $BreakInputIntoFibonacciParts(input)$}
		\For{parte in parts}
			\State{Apply the Oracle embedding $F(part)$}
			\State{Measure the Oracle Qubits}
			\State{Reset these Qubits}
		\EndFor
		\State{Check the outcomes}
		\State{Multiply the given result for its relative $i$}
			
	\end{algorithmic}
	\caption{Quantum Conversion algorithm}
	\label{alg:miles-to-km-quantum-algortihm}
\end{algorithm}

In this algorithm, is needed a preprocessing routine, using a classical algorithm, to split the input number into smaller parts that can be calculated using the sequence. Also, to reduce the amount of Oracle applications to decrease the quantum noise, this processing returns a tuple for each number containing $n$ and the total of applications needed $p$, this way, we can apply each Oracle once and after retrieving the outcomes, the final result is giving by: $\sum_{i=0}^{m} {o_{i}p_{i}}$, being $m$ the total of parts and $o$ the given output.


% fix this one (put each relative number in the Oracle name)
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.18]{number_breakdown_circuit.png}
	\caption{Final Miles to Kilometers Circuit}
	\label{fig:miles-km-circuit}
\end{figure}


\subsubsection{Thoughts on the Results}

With this method, is possible to evaluate some input values. However, there are some points which make it unfeasible.

\begin{description}

\item[Execution Time]{Each part to be calculated, takes too much \emph{shots}, taking around $500-10000$ to get better results, therefore increasing the execution time}

\item[Errors]{Due the high depth of this kind of circuit, this setup is likely to present wrong results due multi-Qubit operations in real hardware}

\item[Impression]{After running the algorithm for many different values, it's clear that, for large numbers, the output deviates a lot from what the expected was}

\item[Classical Intervention]{Once it requires both pre and post-processing using classical algorithms, the usefulness of the quantum version decreases}
\end{description}

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{miles_to_km_defiance.png}
	\caption{Comparing the precision between classical and quantum versions}
	\label{fig:values-miles-km-quantum}
\end{figure}

Thus, this protocol can be used for small numbers. However, to be useful as its classical version, it should be more resilient to errors and precision issues, also it needs to be more independent from classical computations, once most of the work is based on classical routines.

Consequently, this final algorithm isn't good as the classical one, and probably isn't useful enough for real applications. Nonetheless, it's possibly a starting point for different approaches for real implementations. 

\subsection{Hanoi Towers} \label{hanoi}

For the Hanoi Towers implementation, it was designed a way to encode the discs positions in the tower using their binary values and the Phase Oracle as a storage device.

\subsubsection{Implementation}
This project, requires $(\floor{\log_2{x}} + 1) * 3$ Qubits, being $x$ the number of disks. The Qubits layout follows this sequence: $\ket{t_{n-1} t_{n-2} ... t_0}\ket{a_{n-1} a_{n-2} ... a_0}\ket{s_{n-1} s_{n-2} ... s_0}$, where $s$,$a$,$t$ are the first, second and third towers respectively.

To prepare the state, a Phase Oracle is prepared encoding each disc number (from $1$ to $x$) in the first rod (Qubits $s$) using the global phase $\pi$. After that, $SWAP$ operations are done following the classically preprocessed steps, moving bit-by-bit from one rod to another.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{hanoi_3_discs.png}
	\caption{Quantum Hanoi Tower with 3 disks}
	\label{fig:hanoi}
\end{figure}

As cited previously, the movements are preprocessed before playing. This way,the quantum setup acts like a classical player, executing step-by-step his strategy.

Also, as we're playing with phases, it's possible to apply phase amplification algorithm, like Grover's, to evaluate the tower and get the resulting values.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{result_hanoi_3_discs.png}
	\caption{Quantum Hanoi Tower with 3 disks - evaluation using Grover's algorithm}
	\label{fig:hanoi-result}
\end{figure}

As shown in \ref{fig:hanoi-result}, after evaluating the circuit, it's possible to see $3$ high probability bit-strings, which represent the encoded disks. These bit-string are $010000$, $100000$ and $110000$, so the operations moved successfully the disks from the source rod (rightmost $2$ bits) to the target rod (leftmost $2$ bits).

\subsubsection{Thoughts on the Results}

Once it followed the same sequence of implementation as the classical one, requiring, inclusively, preprocessing. This version is equivalent to the classical algorithm, keeping in mind that for a classical computer, it's also required to precompute a movement, and then play it.

\newpage

\subsection{Buckshot Roulette} \label{buckshot}
\emph{Buckshot Roulette} is a computer game made by \href{https://mikeklubnika.itch.io/}{Mike Klubnika}, based on the idea of modifying the infamous Russian Roulette. 

During the game, you are challenged to play against a demon (dealer). If you win, you'll receive a prize, otherwise the game will restart and you can try again.

In this very project, we analyzed the first game match, trying to find the best strategy to maximize the player's winnings. The reason for choosing the first match, is because of its simplicity, being away from power-ups that could complicate the analysis, and also because this one shows the base dynamics for the entire game, so doing well in this one, is the first step to beat the whole game.

\subsubsection{Game Dynamics}

In the first round, $2$ fake bullets and $1$ real are put into the shotgun. Then, the player starts his play, choosing between shooting himself or his opponent. If the player shoots himself and it's a real bullet, he loses one life point, otherwise he gets another chance to choose. However, if he chooses to shot his opponent, if it's real he takes away one life point from him, otherwise his opponent receives the gun.

This dynamics is followed in the entire game for both player and dealer, only being slight modified when power-ups are gained.

\newpage

\subsubsection{Modeling the Game Strategies}
The round dynamics can be modeled as a binary tree, using some game theory ideas to understand it better.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.2]{buckshot-roulette-diagram.png}
	\caption{Buckshot Roulette tree diagram}
	\label{fig:classical-model-bckr}
\end{figure}

For this diagram, it's expected that the player is a rational agent, which always plays aiming to win, and the dealer is a random agent, choosing randomly its decisions. Due that, it's possible to see in the image \ref{fig:classical-model-bckr} that the leafs that was reached by the player, has only one possible value, Shoot, but those reached by the dealer, has two, Shoot himself or his opponent, once he's a random agent.

Using this tree, we can create an algorithm to simulate this game multiple times, and then try to find a possible solution.

After testing multiple possible paths, the best one was given by the path which the player starts shooting the dealer. After Analyzing this very strategy, the conclusion is that, this is the best strategy, because the player has less chances to die, once he doesn't have the chance of killing himself right away at the beginning.

% fix this graph
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{optimal_player_strategy.png}
	\caption{Classical Buckshot Roulette - Best Strategy}
	\label{fig:classical-model-bckr-optimal-strategy}
\end{figure}

\newpage

\begin{table}[h]
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			Bullet & Action & action result & shoot result \\
			\hline
			1 & player shoots himself  & real & dealer wins\\
			\hline
			1 & player shoots himself  & fake & -\\
			\hline
			2 & dealer shoots player  & real & dealer wins\\
			\hline
			2 & dealer shoots player  & fake & -\\
			\hline
			2 & dealer shoots himself  & real & player wins\\
			\hline
			2 & dealer shoots himself  & fake & -\\
			\hline
			3 & player shoots dealer  & real & player wins\\
			\hline
			3 & dealer shoots player & real & dealer wins\\
			\hline
			3 & dealer shoots himself & real & player wins\\
			\hline
		\end{tabular}
		\caption{Player starts shooting himself path analysis}
		\label{table:starts-himself}
	\end{center}
\end{table}

\begin{table}[h]
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
			\hline
			Bullet & Action & action result & shoot result \\
			\hline
			1 & player shoots dealer  & real & player wins\\
			\hline
			1 & player shoots dealer  & fake & -\\
			\hline
			2 & dealer shoots player  & real & dealer wins\\
			\hline
			2 & dealer shoots player  & fake & -\\
			\hline
			2 & dealer shoots himself  & real & player wins\\
			\hline
			2 & dealer shoots himself  & fake & -\\
			\hline
			3 & player shoots dealer  & real & player wins\\
			\hline
			3 & dealer shoots player & real & dealer wins\\
			\hline
			3 & dealer shoots himself & real & player wins\\
			\hline
		\end{tabular}
		\caption{Best Strategy - Analyzing the possible paths}
		\label{table:starts-shooting}
	\end{center}
\end{table}

Analyzing these tables, it's possible to see that the path of which the player starts shooting his opponent \ref{table:starts-shooting}, he has one chance more to win than when he shoots himself first \ref{table:starts-himself}. Due this fact, the \ref{table:starts-shooting} shows the best Strategy to beat the dealer.

\subsubsection{Quantum Version}

After analyzing the game, a quantum circuit was modeled to mimic the game dynamics. To do that, an Oracle was implemented for each player (player and dealer) internally implementing their strategies based on Bloch Sphere rotations.

Also, a \emph{Shoot} gate was implemented. This one, is a controlled Hadamard gate, which implies that the gun has $50\%$ chance of firing (bit $1$) and $50\%$ of not firing (bit $0$), as well.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{quantum_buckshot_roulette.png}
	\caption{Buckshot Roulette Circuit}
	\label{fig:bckr-circuit}
\end{figure}

After setting-up the circuit, two parameters were inserted into Player's Oracle. These were used to manipulated the rotations in the Bloch Sphere in relation to both $\theta$ and $\phi$ angles. This way, it was possible to simulate it multiple times and find the best angles which raise the maximum values of player winnings. After running the algorithm, the best values were: $\theta\approx 3.0853981633974477, \phi\approx3.7853981633974474$ radians.

\newpage


\begin{figure}[h]
	\centering
	\subfloat[\centering Buckshot Roulette (Qiskit Aer) simulation ($shots=1000$) results]{\includegraphics[scale=0.35]{final_buckshot_roulette_quantum_optimal_strategy.png} \label{fig:bckr-circuit-result}}
	\subfloat[\centering Best Strategy Bloch Sphere plot]{\includegraphics[scale=0.35]{player_optimal_strategy_bloch.png} \label{fig:bckr-bloch-sphere-best-strategy}}
	\caption{Buckshot Roulette results}
	\label{fig:buckshot-results}
\end{figure}

Plotting the simulation results on a histogram \ref{fig:bckr-circuit-result}, it's possible to see that the total sum doesn't reach the total of $1000$ shots which were done. It happened due the layout of the circuit, which doesn't take cares of a "game over" state, and keeps running even if the bullet was already shot. Due that, it needed a post-processing function to handle these cases.

Aside of this detail, the results kept really solid, and, comparing to the classical version, the results seem to be the same, and even the player strategy keeps the same, being the best choice shooting his opponent instead of himself \ref{fig:bckr-bloch-sphere-best-strategy} (in this case, $1$ represents the action of shooting the opponent for both players).

\subsubsection{Conclusions}

For this problem, there are no competition between classical and quantum versions, once the former is highly inspired in the later. However, taking a more game theoretical view, the quantum version can take advantage of more states, consequently it can explore more strategies than its counterpart.

In general, both simulations reached the same result, and it was shown that it's possible to model and simulate a game with quantum circuits using Oracles as player's strategies representations.

\subsection{QRAM} \label{qram}

Finally, the last project done was a \emph{QRAM} based on Quantum Oracles. In this version was tested a \emph{QROM}, with static data inside, and a test for a QRAM able to write data inside.

Differing from most part of researches on these devices, in this research the goal was to store all kinds of quantum states, not only bit-strings. The reason for this choice is the real application for this project, if someday a real QRAM was built, its maximum power would be based on storing superposition quantum states.

\subsubsection{QROM}

To implement a QROM, $n$ Qubits are used for the address bus and $m$ for the data bus, but these numbers are not correlated, so it's possible to have a configuration like $n=3; m=10$ using the sequence ${\ket{0}^{\otimes m}} {\ket{a_{n-1} a_{n-2} ... a_0}}$. This happens due the address mapping circuit. In the circuit, when a bit-string address is put on its bus, controlled gates are used to handle the input and map this to the desired state, so the whole application can be done with more than one gate and more than one target Qubit.

\newpage

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{qrom_1.png}
	\caption{QROM circuit example}
	\label{fig:qrom}
\end{figure}


In this example \ref{fig:qrom}, $q_{0}$ represents the address bus and $q_{1}$  the data bus. With this setup, two states were mapped for both possible addresses. In this case, when the value present in the address $0$, the circuit will trigger the controlled $RY({\frac{\pi}{3}})$ gate, applying it on $q_{1}$. The same happens for $1$, but this time, a controlled $H$ is applied, putting the target Qubit in half superposition.

Taking this whole circuit, it can be put inside a Quantum Oracle, and then use it onto a bigger circuit, even taking advantage of superposition for all states with the QROM, just adding either all or some addresses in superposition.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{qrom_1_usage.png}
	\caption{Applying superposition on a QROM}
	\label{fig:qrom-usage}
\end{figure}

Here \ref{fig:qrom-usage}, all possible addresses were put on superposition, and then the resulting states are entangled with \emph{q} .

Although it seems kinda simple, due the no-cloning-theorem, it's not possible to copy internal values and add it in different Qubits. This way, we can only use the state as a entanglement source, or use quantum teleportation to transfer the state from a Qubit to another one.

Also, this kind of memory can become really large depending on its goal, and is required to be reapplied each time it's requested.

\subsubsection{QRAM}

For the QRAM, the quantum teleportation was used, as cite before. With it, we can have a circuit with $n$ qubits, being each Qubit a single address, and then use teleportation to move a state from QRAM's domain to the external circuit domain.

 \begin{figure}[h]
 	\centering
 	\includegraphics[scale=0.4]{qram.png}
 	\caption{QRAM circuit example}
 	\label{fig:qram}
 \end{figure}

In this example case, the first $n$ \emph{data} Qubits act both as data as address, however for teleport their states, additional $n$ Qubits (in this case the Qubits labeled as \emph{t}) being in total $2*n$ Qubits required for the whole protocol.

With that, our circuit Qubits \emph{q} are prepared with some arbitrary states we want to save, then the teleportation protocol is applied and the previous stored data is removed from the circuit and moved to the QRAM domain.

Comparing this implementation with previous one, we have similar characteristics, once both QRAM and QROM can't have their values copied. However, this one doesn't require reapplication for writing, and retrieving values, once they were pre-applied at each data Qubit. Also, it's possible to overwrite and interfere over data estates, this way it's possible to reduce the memory size just managing stored values.

\subsubsection{Conclusion}

Although it's possible to create some sort of memorization inside a circuit, as retreaded at \cite{jaques2023qram} and \cite{Giovannetti_2008}, these devices are far away from a real application. Even using the circuits shown above, the real usage is not simple and practical, being needed many applications, clever data managing protocols and many Qubits, for implementing. It's also affected several implications that reduce its usefulness, like: no-cloning, decoherence, errors, etc.

Due that, the best approach could be implementing memory on hardware, using peripheral devices to connect it to the software and them save or retrieve data when needed.

Based on this discussion, it's possible to conclude that, although it's possible to create sort of memory circuits for small use cases, the extrapolation for bigger ones is far from real. 

\subsection{Final Thoughts}

After all this work, it's evident that Quantum Computing has a big potential for the future. However, the lack of hardware capabilities and some quantum effects affect the real use cases for quantum computing now.

As already shown by many researches in areas like: chemistry, physics, cryptograph, optimization, etc. Quantum computing can be the next breakthrough in technology, and a decisive point for many companies around the world.

However, during NISQ era, to increase the usefulness of such technology, it's still required using classical computing along with it, for both pre- and post-processing routines. This way, using Hybrid approach, it's possible to get the best from both, exploiting the their finest algorithms.

In conclusion, it's possible to take advantage of quantum computing now for some problems we know classically. But, it's needed to investigate if there are some quantum factors that can improve of worsen the results. In case you find out something that can be beneficial for your goal, sometimes taking a hybrid approach on the problem can be a better choice instead of tackling it with pure quantum computations.

\nocite{SOARE2009368}
\nocite{odonnell_2015_lecture}
\nocite{bacon_2006_cse}
\nocite{lipics_stacs}
\nocite{odonnell_2015_lecture_2}
\nocite{brodkorb_2019_the}
\nocite{amreen_oracle}
\nocite{kalyanasyndaram_2021_mod04lec23}
\nocite{davis_2006_turing}
\nocite{viswanathan_2013_reductions}
\nocite{Fan_2007}
\nocite{cryptoeprint:2020/1270}
\nocite{buhrman1998quantum}
\nocite{sanchezrivero2023initial}
\nocite{gilliam2020canonical}
\nocite{Kashefi_2002}
\nocite{e21080800}
\nocite{Zeng_2014}
\nocite{atici2004comparative}
\nocite{sundarappan_2022_how}
\nocite{dai_view}
\nocite{sep-game-theory}
\nocite{Giovannetti_2008}
\nocite{jaques2023qram}
\nocite{PythonEWL2022}
\nocite{frackiewicz2011application}
\nocite{Eisert_1999}
\nocite{usman_2019_kilometres}
\nocite{ldiaandr_2021_tower}
\nocite{diptokarmakar47_2019_how}
\nocite{a2020_towers}
\nocite{geeksforgeeks_2014_program}
\nocite{khan_2021_quantum}
\nocite{legn_2022_dilemma}
\nocite{siegelwax_2022_quantum}
\nocite{landi_density}
\nocite{bacon_2006_cse}
\nocite{vijayakrishnan_2019_role}
\nocite{python_scientific}
\nocite{scipyoptimizeminimize_scalar}
\nocite{davis_optimization}
\nocite{scipyoptimizeminimize}



\bibliographystyle{unsrt}
\bibliography{references}


\end{document}
